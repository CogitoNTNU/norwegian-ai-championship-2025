"""
Generate empty masks for control images in tumor segmentation dataset.

This script creates zero-filled masks for control images (healthy patients)
so they can be included in training with explicit negative examples.

Directory structure expected::
    data/
        raw/
            tumor-segmentation/
                controls/
                    imgs/*.png
                    labels/*.png  (generated by this script)
"""

import os
import cv2
import numpy as np
from glob import glob


def analyze_existing_data(dataset_dir: str):
    """
    Analyze existing patient images AND masks to determine the correct formats.

    Args:
        dataset_dir (str): Path to the dataset directory

    Returns:
        dict: Information about both image and mask formats
    """
    patients_imgs_dir = os.path.join(dataset_dir, "patients", "imgs")
    patients_labels_dir = os.path.join(dataset_dir, "patients", "labels")

    patient_images = sorted(glob(os.path.join(patients_imgs_dir, "*.png")))
    patient_masks = sorted(glob(os.path.join(patients_labels_dir, "*.png")))

    print("=" * 60)
    print("ANALYZING EXISTING PATIENT DATA")
    print("=" * 60)

    image_info = None
    mask_info = None

    # Analyze patient images
    if patient_images:
        print(f"\nFound {len(patient_images)} patient images")
        print("Analyzing patient images:")
        for i, img_path in enumerate(patient_images[:3]):  # Check first 3 images
            img = cv2.imread(img_path, cv2.IMREAD_UNCHANGED)

            if img is None:
                continue

            print(f"  Image {i + 1}: {os.path.basename(img_path)}")
            print(f"    Shape: {img.shape}")
            print(f"    Dtype: {img.dtype}")
            print(
                f"    Channels: {len(img.shape) if len(img.shape) == 2 else img.shape[2] if len(img.shape) == 3 else 'Unknown'}"
            )
            print(f"    Value range: {img.min()} - {img.max()}")

            # Store info from first valid image
            if image_info is None:
                image_info = {
                    "shape": img.shape,
                    "dtype": img.dtype,
                    "has_channels": len(img.shape) == 3,
                    "num_channels": img.shape[2] if len(img.shape) == 3 else 1,
                    "value_range": (img.min(), img.max()),
                }
    else:
        print("No patient images found!")

    # Analyze patient masks
    if patient_masks:
        print(f"\nFound {len(patient_masks)} patient masks")
        print("Analyzing patient masks:")
        for i, mask_path in enumerate(patient_masks[:3]):  # Check first 3 masks
            mask = cv2.imread(mask_path, cv2.IMREAD_UNCHANGED)

            if mask is None:
                continue

            print(f"  Mask {i + 1}: {os.path.basename(mask_path)}")
            print(f"    Shape: {mask.shape}")
            print(f"    Dtype: {mask.dtype}")
            print(
                f"    Channels: {len(mask.shape) if len(mask.shape) == 2 else mask.shape[2] if len(mask.shape) == 3 else 'Unknown'}"
            )
            print(f"    Unique values: {np.unique(mask)}")

            # Store info from first valid mask
            if mask_info is None:
                mask_info = {
                    "shape": mask.shape,
                    "dtype": mask.dtype,
                    "has_channels": len(mask.shape) == 3,
                    "num_channels": mask.shape[2] if len(mask.shape) == 3 else 1,
                    "unique_values": np.unique(mask),
                }
    else:
        print("No patient masks found!")

    # Compare formats
    if image_info and mask_info:
        print("\n" + "=" * 40)
        print("FORMAT COMPARISON:")
        print("=" * 40)
        print(
            f"Images  - Channels: {image_info['num_channels']}, Dtype: {image_info['dtype']}"
        )
        print(
            f"Masks   - Channels: {mask_info['num_channels']}, Dtype: {mask_info['dtype']}"
        )

        if image_info["num_channels"] != mask_info["num_channels"]:
            print("⚠️  WARNING: Images and masks have different number of channels!")
            print("   This could cause the tensor size mismatch error.")
        else:
            print("✅ Images and masks have same number of channels")

        if image_info["dtype"] != mask_info["dtype"]:
            print("ℹ️  INFO: Different data types (common in segmentation)")

    return {"image_info": image_info, "mask_info": mask_info}


def generate_control_masks(dataset_dir: str = "data/raw/tumor-segmentation"):
    """
    Generate empty masks for control images with same format as patient masks.

    Args:
        dataset_dir (str): Path to the dataset directory containing controls/imgs/
    """
    # First, analyze existing patient data to understand formats
    print("Analyzing existing patient data...")
    data_info = analyze_existing_data(dataset_dir)

    mask_info = data_info.get("mask_info")
    image_info = data_info.get("image_info")

    if mask_info is None:
        print(
            "Could not determine mask format from patient data. Using default format."
        )
        mask_info = {"has_channels": False, "num_channels": 1, "dtype": np.uint8}
    else:
        print("\nUsing patient mask format for control masks:")
        print(f"  Channels: {mask_info['num_channels']}")
        print(f"  Dtype: {mask_info['dtype']}")
        print(f"  Has channel dimension: {mask_info['has_channels']}")

    # Configure paths
    controls_imgs_dir = os.path.join(dataset_dir, "controls", "imgs")
    controls_labels_dir = os.path.join(dataset_dir, "controls", "labels")

    # Create labels directory if it doesn't exist
    os.makedirs(controls_labels_dir, exist_ok=True)

    # Get all control images
    control_images = sorted(glob(os.path.join(controls_imgs_dir, "*.png")))

    if not control_images:
        print(f"No PNG images found in {controls_imgs_dir}")
        return

    print("\nGenerating control masks...")
    print(f"Found {len(control_images)} control images")
    print(f"Will save masks to: {controls_labels_dir}")

    # Also analyze control images to see their format
    print("\nControl image format check:")
    sample_control = cv2.imread(control_images[0], cv2.IMREAD_UNCHANGED)
    if sample_control is not None:
        print(f"  Control image shape: {sample_control.shape}")
        print(f"  Control image dtype: {sample_control.dtype}")

        # Warn if control images don't match patient images
        if image_info and sample_control.shape != image_info["shape"][:2]:
            print(
                "⚠️  WARNING: Control images have different dimensions than patient images!"
            )

    for img_path in control_images:
        # Load the image to get dimensions
        image = cv2.imread(img_path, cv2.IMREAD_UNCHANGED)

        if image is None:
            print(f"Warning: Could not load {img_path}")
            continue

        # Get height and width
        if len(image.shape) == 3:
            height, width, _ = image.shape
        else:
            height, width = image.shape

        # Create empty mask with same format as patient masks
        if mask_info["has_channels"] and mask_info["num_channels"] > 1:
            # Multi-channel mask (e.g., for multi-class segmentation)
            empty_mask = np.zeros(
                (height, width, mask_info["num_channels"]), dtype=mask_info["dtype"]
            )
        else:
            # Single channel mask
            empty_mask = np.zeros((height, width), dtype=mask_info["dtype"])

        # Generate output filename
        img_filename = os.path.basename(img_path)
        mask_filename = img_filename  # Keep same filename for consistency
        mask_path = os.path.join(controls_labels_dir, mask_filename)

        # Save the empty mask with appropriate method
        if mask_info["has_channels"] and mask_info["num_channels"] > 1:
            # For multi-channel, save with cv2.IMWRITE_UNCHANGED flag
            success = cv2.imwrite(
                mask_path, empty_mask, [cv2.IMWRITE_PNG_COMPRESSION, 0]
            )
        else:
            # For single channel
            success = cv2.imwrite(mask_path, empty_mask)

        if not success:
            print(f"Failed to save mask: {mask_filename}")

    print(f"\nSuccessfully generated {len(control_images)} empty masks")
    print(f"Control masks saved to: {controls_labels_dir}")


def verify_control_masks(dataset_dir: str = "data/raw/tumor-segmentation"):
    """
    Verify that control masks were created correctly and match patient mask format.

    Args:
        dataset_dir (str): Path to the dataset directory
    """
    controls_imgs_dir = os.path.join(dataset_dir, "controls", "imgs")
    controls_labels_dir = os.path.join(dataset_dir, "controls", "labels")
    patients_labels_dir = os.path.join(dataset_dir, "patients", "labels")

    # Get files
    control_images = sorted(glob(os.path.join(controls_imgs_dir, "*.png")))
    control_masks = sorted(glob(os.path.join(controls_labels_dir, "*.png")))
    patient_masks = sorted(glob(os.path.join(patients_labels_dir, "*.png")))

    print("\nVerification Results:")
    print(f"Control images: {len(control_images)}")
    print(f"Control masks: {len(control_masks)}")
    print(f"Patient masks: {len(patient_masks)} (for reference)")

    if len(control_images) != len(control_masks):
        print("❌ Mismatch between number of images and masks!")
        return False

    # Load a patient mask for reference
    reference_mask = None
    if patient_masks:
        reference_mask = cv2.imread(patient_masks[0], cv2.IMREAD_UNCHANGED)
        if reference_mask is not None:
            print("\nReference patient mask format:")
            print(f"  Shape: {reference_mask.shape}")
            print(f"  Dtype: {reference_mask.dtype}")

    # Check control masks
    mismatches = 0
    for i, (img_path, mask_path) in enumerate(zip(control_images, control_masks)):
        img = cv2.imread(img_path, cv2.IMREAD_UNCHANGED)
        mask = cv2.imread(mask_path, cv2.IMREAD_UNCHANGED)

        if img is None or mask is None:
            print(f"❌ Could not load: {os.path.basename(img_path)}")
            mismatches += 1
            continue

        # Check image-mask dimension compatibility
        img_h, img_w = img.shape[:2]
        mask_h, mask_w = mask.shape[:2]

        if img_h != mask_h or img_w != mask_w:
            print(f"❌ Dimension mismatch: {os.path.basename(img_path)}")
            print(f"   Image: {img.shape}, Mask: {mask.shape}")
            mismatches += 1
            continue

        # Check that mask is all zeros
        if not np.all(mask == 0):
            print(f"❌ Mask not empty: {os.path.basename(mask_path)}")
            mismatches += 1
            continue

        # Check format consistency with patient masks
        if reference_mask is not None:
            if len(mask.shape) != len(reference_mask.shape):
                print(
                    f"❌ Channel dimension mismatch with patient masks: {os.path.basename(mask_path)}"
                )
                print(
                    f"   Control mask shape: {mask.shape}, Patient mask shape: {reference_mask.shape}"
                )
                mismatches += 1
                continue

            if len(mask.shape) == 3 and mask.shape[2] != reference_mask.shape[2]:
                print(
                    f"❌ Channel count mismatch with patient masks: {os.path.basename(mask_path)}"
                )
                print(
                    f"   Control: {mask.shape[2]} channels, Patient: {reference_mask.shape[2]} channels"
                )
                mismatches += 1
                continue

        if i < 3:  # Show details for first few masks
            print(f"✅ Control mask {i + 1}: {os.path.basename(mask_path)}")
            print(f"   Shape: {mask.shape}, Dtype: {mask.dtype}")

    if mismatches == 0:
        print(
            "\n✅ All control masks generated correctly and match patient mask format!"
        )
        return True
    else:
        print(f"\n❌ Found {mismatches} issues with control masks")
        return False


def compare_sample_data(dataset_dir: str = "data/raw/tumor-segmentation"):
    """
    Compare a few samples from patients and controls to ensure compatibility.
    """
    print("\n" + "=" * 50)
    print("SAMPLE DATA COMPARISON")
    print("=" * 50)

    # Load samples
    patients_imgs = sorted(glob(os.path.join(dataset_dir, "patients", "imgs", "*.png")))
    patients_segs = sorted(
        glob(os.path.join(dataset_dir, "patients", "labels", "*.png"))
    )
    controls_imgs = sorted(glob(os.path.join(dataset_dir, "controls", "imgs", "*.png")))
    controls_segs = sorted(
        glob(os.path.join(dataset_dir, "controls", "labels", "*.png"))
    )

    # Compare first sample from each
    samples = [
        ("Patient Image", patients_imgs[0] if patients_imgs else None),
        ("Patient Mask", patients_segs[0] if patients_segs else None),
        ("Control Image", controls_imgs[0] if controls_imgs else None),
        ("Control Mask", controls_segs[0] if controls_segs else None),
    ]

    for name, path in samples:
        if path and os.path.exists(path):
            data = cv2.imread(path, cv2.IMREAD_UNCHANGED)
            if data is not None:
                print(
                    f"{name:15}: {data.shape:15} {str(data.dtype):10} {os.path.basename(path)}"
                )
            else:
                print(f"{name:15}: Failed to load {os.path.basename(path)}")
        else:
            print(f"{name:15}: Not found")


if __name__ == "__main__":
    # Default dataset directory (relative to project root)
    dataset_dir = "../data/raw/tumor-segmentation"

    # Check if the directory exists
    if not os.path.exists(dataset_dir):
        # Try alternative path if running from segmentation folder
        dataset_dir = "data/raw/tumor-segmentation"

    if not os.path.exists(dataset_dir):
        print(f"Dataset directory not found: {dataset_dir}")
        print("Please update the dataset_dir path in the script")
        exit(1)

    print("Generating empty masks for control images...")
    print(f"Dataset directory: {os.path.abspath(dataset_dir)}")

    # Generate the masks
    generate_control_masks(dataset_dir)

    # Verify the results
    verify_control_masks(dataset_dir)

    # Compare sample data
    compare_sample_data(dataset_dir)

    print("\n" + "=" * 60)
    print("READY FOR TRAINING!")
    print("=" * 60)
    print("Your control masks now match the patient mask format.")
    print("You can now run your training script with both patients and controls.")
